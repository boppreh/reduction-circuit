<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width" />
        <title>Circuit</title>
        <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font: 16px sans-serif;
            color: #CCC;
        }
        canvas {
            background-color: #EEE;
            background-color: #456990;
        }
        </style>
    </head>
    <body>
        <canvas></canvas>
        <script>
"use strict";

var canvas = document.getElementsByTagName("canvas")[0];
var context = canvas.getContext("2d");
context.strokeStyle = "black";
context.strokeWidth = 1;
context.save();

var hash = window.location.hash;

function Circuit(f) {
    var r = f.slice(1);
    var m = f[0];
    var d = 2*m - 2;
    var reductionState = [];
    var squaringState = [];
    for (var i = 0; i <= d; i++) {
        reductionState.push(1);
        squaringState.push(0);
    }
    var operationState = squaringState;

    var padding = 40;
    var startY = padding;
    var xorRadius = 10;
    var xorPadding = 10;
    var curveRadius = 8;

    function heightY(height) {
        return startY + (xorPadding + 2 * xorRadius) * (height + 1);
    }
    function columnWidth() {
        return Math.ceil((canvas.width - 2 * padding) / d);
    }
    function columnX(col) {
        return padding + (d - col) * columnWidth();
    }
    function xColumn(x) {
        return Math.round(d - (x - padding) / columnWidth());
    }

    function drawNumbers() {
        context.textAlign = "center";
        context.font = "26px mono";
        for (var i = 0; i <= d; i++) {
            context.fillText(i, columnX(i), padding * 3/4, columnWidth());
        }
    }

    function drawLines(xorsPerColumn) {
        function drawXor(x, y) {
            context.stroke();
            context.beginPath();

            context.save();
            context.lineWidth += 1;
            context.moveTo(x, y);
            context.arc(x, y, xorRadius, 0, Math.PI * 2);
            context.moveTo(x-xorRadius, y);
            context.lineTo(x+xorRadius, y);
            context.moveTo(x, y-xorRadius);
            context.lineTo(x, y+xorRadius);
            context.stroke();
            context.restore();

            context.beginPath();
        }

        context.beginPath();

        for (var i = 0; i < xorsPerColumn.length; i++) {
            var xors = xorsPerColumn[i];
            context.moveTo(columnX(i), startY);
            context.lineTo(columnX(i), heightY(0)+curveRadius);
            var xor = xors[0];
            for (var j = 1; j < xors.length; j++) {
                xor = xors[j];
                var x = columnX(xor.column);
                var y = heightY(xor.height);
                var rightX = columnX(xor.rightXor.column);
                context.moveTo(rightX, heightY(xor.rightXor.height));
                context.lineTo(rightX, y-curveRadius);
                context.quadraticCurveTo(rightX, y, rightX+curveRadius, y);
                context.lineTo(x-curveRadius, y);

                if (xor.rightXor !== xor.leftXor) {
                    context.lineTo(x, y);
                    context.lineTo(x, heightY(xor.leftXor.height)+curveRadius);
                    drawXor(x, y);
                    context.moveTo(x, y);
                    context.lineTo(x, y+curveRadius);
                } else {
                    context.quadraticCurveTo(x, y, x, y+curveRadius);
                }
            }
            if (i < m) {
                if (xor.height) {
                    context.moveTo(columnX(i), heightY(xor.height)+curveRadius);
                } else {
                    context.moveTo(columnX(i), heightY(0)+curveRadius);
                }
                context.lineTo(columnX(i), canvas.height);
            }
        }
        context.stroke();
    }

    function computeXorStructure(assignmentState) {
        assignmentState = assignmentState.slice(0); // clone array.

        var xorsPerColumn = [];
        for (var i = 0; i <= d; i++) {
            xorsPerColumn[i] = [{"height": 0, "column": i, "delay": 0}];
        }
        var height = 0;
        for (var i = d; i >= m; i--) {
            var right = i;
            if (right%2 && assignmentState[right] == 0) {
                continue;
            }
            for (var j = 0; j < r.length; j++) {
                var left = right - m + r[j];
                var rightXors = xorsPerColumn[right];
                var lastRightXor = rightXors[rightXors.length-1];
                var leftXors = xorsPerColumn[left];
                var lastLeftXor = leftXors[leftXors.length-1];
                var lastLeftDelay = lastLeftXor.delay;
                var lastRightDelay = lastRightXor.delay;
                if (left%2 && assignmentState[left] == 0) {
                    xorsPerColumn[left].push({"height": height++, "column": left, "leftXor": lastRightXor, "rightXor": lastRightXor, "delay": lastRightDelay});
                } else {
                    var delay = Math.max(lastLeftDelay, lastRightDelay) + 1;
                    xorsPerColumn[left].push({"height": height++, "column": left, "leftXor": lastLeftXor, "rightXor": lastRightXor, "delay": delay});
                }
                assignmentState[left] = 1;
            }
        }
        return xorsPerColumn;
    }

    function walkUp(xor) {
        if (xor) {
            return [xor].concat(walkUp(xor.leftXor)).concat(walkUp(xor.rightXor));
        } else {
            return [];
        }
    }

    function relatedXors(column, xorsPerColumn) {
        var columnXors = xorsPerColumn[column];
        var lastXor = columnXors[columnXors.length-1];
        return walkUp(lastXor);
    }

    function computeCriticalPath(xors) {
        var xor = xors[xors.length-1];
        var criticalPath = [xor];
        while (xor.rightXor) {
            xor = (xor.rightXor.delay >= xor.leftXor.delay) ? xor.rightXor : xor.leftXor;
            criticalPath.push(xor);
        }
        return criticalPath;
    }

    function drawXorPath(path) {
        context.save();
        context.strokeStyle = "#502010";
        context.lineWidth = 3;
        context.beginPath();
        var lastColumn = path[0].column;
        var lastY = startY;
        context.moveTo(columnX(lastColumn), canvas.height);
        for (var i = 0; i < path.length; i++) {
            var xor = path[i];
            var y = heightY(xor.height);
            if (lastColumn != xor.column) {
                context.lineTo(columnX(xor.column), lastY);
            }
            context.lineTo(columnX(xor.column), y);
            lastColumn = xor.column;
            lastY = y;
        }
        context.lineTo(columnX(xor.column), startY);
        context.stroke();
        context.restore();
    }

    function drawDelays(xorsPerColumn) {
        context.save();
        context.textAlign = "left";
        context.font = "18px mono";
        context.fillStyle = "#502010";
        for (var i = 0; i <= d; i++) {
            var xors = xorsPerColumn[i];
            var last = xors[xors.length - 1];
            var delay = last ? last.delay : 0;
            context.fillText(delay, columnX(i)+5, canvas.height - padding + 18);
        }
        context.restore();
    }

    var xorsPerColumn = computeXorStructure(operationState);
    function redrawEverything(highlightedColumn) {
        highlightedColumn = Math.max(0, Math.min(d, highlightedColumn));
        var highlightedXors = relatedXors(highlightedColumn, xorsPerColumn);

        context.save();

        context.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        xorRadius = Math.ceil(canvas.height / (d * f.length) / 2);
        xorPadding = xorRadius;

        drawNumbers();
        drawLines(xorsPerColumn);
        drawDelays(xorsPerColumn);
        drawXorPath(computeCriticalPath(xorsPerColumn[highlightedColumn]));

        context.restore();
    }

    function computeDelay() {
        var maxDelay = -1;
        for (var i = 0; i < xorsPerColumn.length; i++) {
            var xors = xorsPerColumn[i];
            maxDelay = Math.max(maxDelay, xors[xors.length-1].delay);
        }
        return maxDelay;
    }

    return {
        "redrawEverything": redrawEverything,
        "computeDelay": computeDelay,
        "xColumn": xColumn,
    };
}


function debounce(fn, timeout) {
    var id;
    return function(e) {
        if (id) {
            clearTimeout(id);
        }
        id = setTimeout(function() { fn(e) }, timeout);
    }
}

var f;
if (hash) {
    f = window.location.hash.slice(1).split(',').map(Number);
} else {
    f = [7, 6, 2, 1, 0];
}
var circuit = new Circuit(f);

var lastColumnSelected = f[1];

circuit.redrawEverything(lastColumnSelected);
window.addEventListener("resize", debounce(function() {
    circuit.redrawEverything(lastColumnSelected);
}, 100));
window.addEventListener("mousemove", function(event) {   
    var column = circuit.xColumn(event.clientX);
    if (column != lastColumnSelected) {
        lastColumnSelected = column;
        circuit.redrawEverything(lastColumnSelected);
    }
});

//alert(Circuit([163,7,6,3,0]).computeDelay()); // 4
//alert(Circuit([283,12,7,5,0]).computeDelay()); // 4
//alert(Circuit([571,10,5,2,0]).computeDelay()); // 3
/*
//for (var m = 11; m <= 21; m+=2) {
for (var m = 101; m <= 101; m+=2) {
    for (var c = 1; c < m-2; c++) {
        for (var b = c+1; b < m-1; b++) {
            for (var a = b+1; a < m/2; a++) {
                console.log("x^"+m+" + x^"+a+" + x^"+b+" + x^"+c+" + 1 -> ", Circuit([m, a, b, c, 0]).computeDelay());
            }
        }
    }
}
*/


        </script>
    </body>
</html>
